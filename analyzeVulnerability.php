<?php

// Include the necessary configurations and Gemini AI logic
include './src/config/Database.php'; // Database connection
include 'GeminiAI.php'; // Gemini AI for advanced vulnerability analysis

class VulnerabilityAnalyzer
{
    private $conn;

    public function __construct($dbConnection)
    {
        $this->conn = $dbConnection;
    }

    // Analyze application vulnerabilities
    public function analyzeApplication($applicationData)
    {
        foreach ($applicationData as $data) {
            if ($this->isVulnerable($data)) {
                // Store detected vulnerabilities in the database
                $this->storeVulnerability($data);
            }
        }
    }

    // Determine if application data contains vulnerabilities
    private function isVulnerable($data)
    {
        return $this->isSQLInjection($data['input']) ||
               $this->isXSS($data['input']) ||
               $this->isFileUploadVulnerability($data['file']);
    }

    // Check for SQL Injection vulnerability
    private function isSQLInjection($input)
    {
        // Simple SQL Injection detection (replace with more comprehensive checks)
        $patterns = [
            '/union.*select/i',
            '/select.*from/i',
            '/drop.*table/i'
        ];

        foreach ($patterns as $pattern) {
            if (preg_match($pattern, $input)) {
                return true;
            }
        }
        return false;
    }

    // Check for Cross-Site Scripting (XSS) vulnerability
    private function isXSS($input)
    {
        // Simple XSS detection (replace with more comprehensive checks)
        $patterns = [
            '/<script.*>/i',
            '/<img.*onerror=.*>/i',
            '/<iframe.*>/i'
        ];

        foreach ($patterns as $pattern) {
            if (preg_match($pattern, $input)) {
                return true;
            }
        }
        return false;
    }

    // Check for File Upload vulnerabilities
    private function isFileUploadVulnerability($file)
    {
        // Check file extension and MIME type (replace with comprehensive checks)
        $allowedExtensions = ['jpg', 'png', 'pdf'];
        $fileExtension = pathinfo($file['name'], PATHINFO_EXTENSION);

        return !in_array($fileExtension, $allowedExtensions);
    }

    // Store detected vulnerabilities in the database
    private function storeVulnerability($data)
    {
        $query = "INSERT INTO detected_vulnerabilities (vulnerability_type, details, detection_time) 
                  VALUES (:vulnerability_type, :details, :detection_time)";
        $stmt = $this->conn->prepare($query);

        // Bind parameters
        $stmt->bindParam(':vulnerability_type', $data['type']);
        $stmt->bindParam(':details', json_encode($data['details']));
        $stmt->bindParam(':detection_time', date('Y-m-d H:i:s'));

        // Execute the query
        $stmt->execute();

        // Log the detected vulnerabilities
        $this->logVulnerability($data);
    }

    // Log detected vulnerabilities into a log file
    private function logVulnerability($data)
    {
        $logEntry = "Detected Vulnerability: Type: " . $data['type'] . 
                    ", Details: " . json_encode($data['details']) . 
                    ", Detected at: " . date('Y-m-d H:i:s') . PHP_EOL;

        // Write the log entry to a log file
        file_put_contents('./logs/detected_vulnerabilities.log', $logEntry, FILE_APPEND);
    }

    // Fetch all detected vulnerabilities for real-time display or review
    public function getAllDetectedVulnerabilities()
    {
        $query = "SELECT * FROM detected_vulnerabilities ORDER BY detection_time DESC";
        $stmt = $this->conn->prepare($query);
        $stmt->execute();

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}

// Example usage of this file would involve:
// Including it in the appropriate script to analyze application data
// and displaying the results in real-time.