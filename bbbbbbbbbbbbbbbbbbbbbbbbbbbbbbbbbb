import os
import subprocess
import time
import threading
import signal
import logging
from logging.handlers import RotatingFileHandler
from scapy.all import ARP, Ether, srp
import netifaces
import mysql.connector
from datetime import datetime, timedelta
import socket
import json
from dataclasses import dataclass
from typing import Dict, Set, Optional, Tuple, List
from functools import lru_cache
import sys
from threading import Lock
from collections import defaultdict

# Configuration
DB_CONFIG = {
    'host': 'localhost',
    'user': 'root',
    'password': '',
    'database': 'securityapp'
}

DEVICE_TIMEOUT = 300  # 5 minutes in seconds
SCAN_INTERVAL = 5  # seconds


traffic_data = defaultdict(lambda: {
    'in_bytes': 0, 
    'out_bytes': 0, 
    'in_pkts': 0, 
    'out_pkts': 0
})


mac_ip_mapping = {}
data_lock = Lock()
mapping_lock = Lock()

@dataclass
class DeviceStats:
    mac: str
    ip: str
    hostname: str
    data_usage_mb: float
    last_seen: datetime
    connection_count: int
    status: str
    is_permanent: bool

class TrafficMonitor:
    def __init__(self):
        self.logger = logging.getLogger('TrafficMonitor')
        self.last_counter_values = defaultdict(lambda: {'in': 0, 'out': 0})
        self.ensure_accounting_setup()
        
    def ensure_accounting_setup(self):
        """Ensure proper accounting setup using nftables"""
        try:
            # Check if accounting table exists
            result = subprocess.run(
                ["nft", "list", "table", "inet", "traffic_accounting"],
                stderr=subprocess.PIPE, stdout=subprocess.PIPE
            )
            
            if result.returncode != 0:
                # Create accounting table and chain
                subprocess.run([
                    "nft", "add", "table", "inet", "traffic_accounting"
                ], check=True)
                
                subprocess.run([
                    "nft", "add", "chain", "inet", "traffic_accounting", "input_chain",
                    "{ type filter hook input priority 0 ; policy accept ; }"
                ], check=True)
                
                subprocess.run([
                    "nft", "add", "chain", "inet", "traffic_accounting", "output_chain",
                    "{ type filter hook output priority 0 ; policy accept ; }"
                ], check=True)
                
                # Create counters set
                subprocess.run([
                    "nft", "add", "set", "inet", "traffic_accounting", "device_counters",
                    "{ type ether_addr . ipv4_addr ; flags dynamic ; }"
                ], check=True)
                
                self.logger.info("Created nftables accounting setup")
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Accounting setup failed: {e.stderr.decode()}")
            raise

    

    def update_device_rules(self, devices: List[Tuple[str, str, str]]):
        """Update nftables rules with reliable counting method"""
        try:
            # Delete and recreate the entire table
            subprocess.run(
                ["nft", "delete", "table", "inet", "traffic_accounting"],
                stderr=subprocess.DEVNULL
            )
            
            # Create fresh table and chains with raw priority
            subprocess.run([
                "nft", "add", "table", "inet", "traffic_accounting"
            ], check=True)
            
            # Input chain (very early in packet processing)
            subprocess.run([
                "nft", "add", "chain", "inet", "traffic_accounting", "input_chain",
                "{ type filter hook input priority raw ; policy accept ; }"
            ], check=True)
            
            # Output chain (very early in packet processing)
            subprocess.run([
                "nft", "add", "chain", "inet", "traffic_accounting", "output_chain",
                "{ type filter hook output priority raw ; policy accept ; }"
            ], check=True)

            # Clear existing mappings
            with mapping_lock:
                mac_ip_mapping.clear()

            # Add reliable rules for each device
            for ip, mac, _ in devices:
                with mapping_lock:
                    mac_ip_mapping[mac.lower()] = ip
                
                # Input rule - count by MAC (most reliable)
                subprocess.run([
                    "nft", "add", "rule", "inet", "traffic_accounting", "input_chain",
                    f"ether saddr {mac.lower()} counter"
                ], check=True)
                
                # Output rule - count by IP
                subprocess.run([
                    "nft", "add", "rule", "inet", "traffic_accounting", "output_chain",
                    f"ip daddr {ip} counter"
                ], check=True)
                
            self.logger.info(f"Updated traffic rules for {len(devices)} devices")
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Rule update failed: {e.stderr.decode() if e.stderr else str(e)}")


    def collect_traffic_stats(self):
        """Collect traffic statistics with bulletproof parsing"""
        try:
            # Get nftables JSON output
            result = subprocess.run(
                ["nft", "-j", "list", "table", "inet", "traffic_accounting"],
                capture_output=True, text=True, check=True
            )
            
            # Debug: Log raw output
            self.logger.info(f"Raw nftables output:\n{result.stdout}")
            
            data = json.loads(result.stdout)
            current_stats = defaultdict(lambda: {'in_bytes': 0, 'out_bytes': 0})
            
            # Parse all rules
            for item in data.get('nftables', []):
                if 'rule' not in item:
                    continue
                    
                rule = item['rule']
                if 'counter' not in rule:
                    continue
                    
                # Get counter values
                bytes_val = int(rule['counter']['bytes'])
                pkts_val = int(rule['counter']['packets'])
                
                # Parse expressions
                for expr in rule.get('expr', []):
                    if not isinstance(expr, dict):
                        continue
                        
                    # Match input traffic by MAC
                    if 'match' in expr:
                        match = expr['match']
                        left = match.get('left', {})
                        if isinstance(left, dict) and left.get('payload', {}).get('field') == 'saddr':
                            mac = match['right'].lower().replace('"', '').replace("'", "")
                            current_stats[mac]['in_bytes'] = bytes_val
                            self.logger.info(f"Found input traffic for {mac}: {bytes_val} bytes")
                            break
                            
                        # Match output traffic by IP
                        if isinstance(left, dict) and left.get('payload', {}).get('field') == 'daddr':
                            ip = match['right'].replace('"', '').replace("'", "")
                            with mapping_lock:
                                mac = next((m for m, i in mac_ip_mapping.items() if i == ip), None)
                            if mac:
                                current_stats[mac]['out_bytes'] = bytes_val
                                self.logger.info(f"Found output traffic for {mac}: {bytes_val} bytes")
                            break
            
            # Update traffic_data with deltas
            with data_lock:
                for mac, stats in current_stats.items():
                    # Initialize if needed
                    if mac not in traffic_data:
                        traffic_data[mac] = {'in_bytes': 0, 'out_bytes': 0}
                    if mac not in self.last_counter_values:
                        self.last_counter_values[mac] = {'in_bytes': 0, 'out_bytes': 0}
                    
                    # Calculate deltas (handle counter reset)
                    in_bytes = stats['in_bytes']
                    last_in = self.last_counter_values[mac]['in_bytes']
                    in_bytes_delta = in_bytes - last_in if in_bytes >= last_in else in_bytes
                    
                    out_bytes = stats['out_bytes']
                    last_out = self.last_counter_values[mac]['out_bytes']
                    out_bytes_delta = out_bytes - last_out if out_bytes >= last_out else out_bytes
                    
                    # Update traffic data
                    if in_bytes_delta > 0:
                        traffic_data[mac]['in_bytes'] += in_bytes_delta
                    if out_bytes_delta > 0:
                        traffic_data[mac]['out_bytes'] += out_bytes_delta
                    
                    # Update last counters
                    self.last_counter_values[mac] = {
                        'in_bytes': in_bytes,
                        'out_bytes': out_bytes
                    }
                    
                    self.logger.info(f"Updated traffic for {mac}: in={traffic_data[mac]['in_bytes']} out={traffic_data[mac]['out_bytes']}")
            
            # Debug: Log final traffic_data
            self.logger.info(f"Final traffic_data: {dict(traffic_data)}")
            
        except Exception as e:
            self.logger.error(f"Traffic collection failed: {str(e)}")
            raise


class NetworkEnforcer:
    def __init__(self):
        self.blocked_macs: Set[str] = set()
        self.device_stats: Dict[str, DeviceStats] = {}
        self.traffic_monitor = TrafficMonitor()
        self.setup_logging()
        self.setup_persistent_nftables()
        
    def setup_logging(self):
        """Configure professional logging with rotation."""
        log_handler = RotatingFileHandler(
            '/opt/lampp/htdocs/securitysite/logs/network_enforcer.log',
            maxBytes=10*1024*1024,
            backupCount=5
        )
        log_handler.setFormatter(logging.Formatter(
            '%(asctime)s [%(levelname)s] [%(module)s:%(funcName)s] %(message)s',
            datefmt='%Y-%m-%d %H:%M:%S'
        ))
        self.logger = logging.getLogger('NetworkEnforcer')
        self.logger.setLevel(logging.INFO)
        self.logger.addHandler(log_handler)
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(log_handler.formatter)
        self.logger.addHandler(console_handler)
        
    def setup_persistent_nftables(self):
        """Configure nftables with persistent MAC filtering rules."""
        try:
            # Check if our table exists
            subprocess.run(["nft", "list", "table", "inet", "mac_filter"], 
                         stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL)
            self.logger.debug("nftables already configured")
        except subprocess.CalledProcessError:
            try:
                # Create a dedicated table for our rules
                subprocess.run(["nft", "add", "table", "inet", "mac_filter"], check=True)
                
                # Create input chain with default accept policy
                subprocess.run([
                    "nft", "add", "chain", "inet", "mac_filter", "input",
                    "{ type filter hook input priority 0 ; policy accept ; }"
                ], check=True)
                
                # Create forward chain with default accept policy
                subprocess.run([
                    "nft", "add", "chain", "inet", "mac_filter", "forward",
                    "{ type filter hook forward priority 0 ; policy accept ; }"
                ], check=True)
                
                # Create MAC blocking set
                subprocess.run([
                    "nft", "add", "set", "inet", "mac_filter", "blocked_macs",
                    "{ type ether_addr ; flags timeout ; }"
                ], check=True)
                
                # Add rule to block devices in our set
                subprocess.run([
                    "nft", "add", "rule", "inet", "mac_filter", "input",
                    "ether saddr @blocked_macs drop"
                ], check=True)
                
                subprocess.run([
                    "nft", "add", "rule", "inet", "mac_filter", "forward",
                    "ether saddr @blocked_macs drop"
                ], check=True)
                
                # Make rules persistent
                subprocess.run(["nft", "list", "ruleset"], stdout=open("/etc/nftables.conf", "w"), check=True)
                subprocess.run(["systemctl", "enable", "nftables"], check=True)
                subprocess.run(["systemctl", "restart", "nftables"], check=True)
                
                self.logger.info("Persistent nftables configured successfully")
            except subprocess.CalledProcessError as e:
                self.logger.error(f"nftables setup failed: {e}")
                raise

    def update_blocked_devices(self):
        """Update nftables rules based on disconnected devices from database."""
        conn = get_db_connection()
        if not conn:
            return
            
        try:
            cursor = conn.cursor()
            
            # Get all devices that should be blocked (disconnected status)
            cursor.execute("""
                SELECT mac_address 
                FROM active_users_log 
                WHERE status = 'disconnected'
            """)
            db_blocked_macs = {row[0].lower() for row in cursor.fetchall()}
            
            # Block new devices
            for mac in db_blocked_macs - self.blocked_macs:
                self.block_mac(mac)
                
            # Unblock devices that shouldn't be blocked anymore
            for mac in self.blocked_macs - db_blocked_macs:
                self.unblock_mac(mac)
                
            self.blocked_macs = db_blocked_macs
                
        except Exception as e:
            self.logger.error(f"Database error updating blocked devices: {e}")
        finally:
            cursor.close()
            conn.close()
            
    def block_mac(self, mac: str) -> bool:
        """Block a device by MAC address."""
        try:
            # Add the MAC to our blocking set
            subprocess.run([
                "nft", "add", "element", "inet", "mac_filter", "blocked_macs",
                "{ " + mac.lower() + " }"
            ], check=True)
            
            self.blocked_macs.add(mac.lower())
            self.logger.info(f"Blocked MAC: {mac}")
            
            # Make the rule persistent
            subprocess.run(["nft", "list", "ruleset"], stdout=open("/etc/nftables.conf", "w"), check=True)
            return True
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to block MAC {mac}: {e}")
            return False
            
    def unblock_mac(self, mac: str) -> bool:
        """Unblock a device by MAC address."""
        try:
            # Remove the MAC from our blocking set
            subprocess.run([
                "nft", "delete", "element", "inet", "mac_filter", "blocked_macs",
                "{ " + mac.lower() + " }"
            ], check=True)
                
            self.blocked_macs.discard(mac.lower())
            self.logger.info(f"Unblocked MAC: {mac}")
            
            # Update persistent rules
            subprocess.run(["nft", "list", "ruleset"], stdout=open("/etc/nftables.conf", "w"), check=True)
            return True
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Failed to unblock MAC {mac}: {e}")
            return False

def get_db_connection():
    """Establish a database connection."""
    try:
        conn = mysql.connector.connect(**DB_CONFIG)
        conn.autocommit = False
        return conn
    except mysql.connector.Error as e:
        logging.getLogger('NetworkEnforcer').error(f"Database connection failed: {e}")
        return None

def update_database_usage():
    """Update database with traffic statistics"""
    conn = get_db_connection()
    if not conn:
        logging.getLogger('NetworkEnforcer').error("Database connection failed")
        return
        
    try:
        cursor = conn.cursor()
        updated_count = 0
        
        with data_lock:
            # Process all devices with traffic
            for mac, stats in traffic_data.items():
                in_bytes = stats.get('in_bytes', 0)
                out_bytes = stats.get('out_bytes', 0)
                
                if in_bytes > 0 or out_bytes > 0:
                    # Convert to MB
                    in_mb = in_bytes / (1024 * 1024)
                    out_mb = out_bytes / (1024 * 1024)
                    total_mb = (in_bytes + out_bytes) / (1024 * 1024)
                    
                    # Update database
                    cursor.execute(
                        """
                        UPDATE active_users_log 
                        SET 
                            data_in_mb = data_in_mb + %s,
                            data_out_mb = data_out_mb + %s,
                            data_usage_mb = data_usage_mb + %s,
                            last_seen = NOW()
                        WHERE mac_address = %s
                        """,
                        (in_mb, out_mb, total_mb, mac.lower())
                    )
                    
                    if cursor.rowcount > 0:
                        updated_count += 1
                        # Reset counters
                        traffic_data[mac]['in_bytes'] = 0
                        traffic_data[mac]['out_bytes'] = 0
                    else:
                        logging.getLogger('NetworkEnforcer').warning(f"No record found for MAC {mac}")
        
        conn.commit()
        logging.getLogger('NetworkEnforcer').info(f"Updated {updated_count} devices in database")
        
    except Exception as e:
        logging.getLogger('NetworkEnforcer').error(f"Database update failed: {e}")
        if conn:
            conn.rollback()
    finally:
        if cursor:
            cursor.close()
        if conn:
            conn.close()

def save_to_db(ip: str, mac_address: str, hostname: str, status: str = 'connected') -> None:
    """Ensure device exists in database before updating traffic stats"""
    logger = logging.getLogger('NetworkEnforcer')
    db_connection = get_db_connection()
    
    if not db_connection:
        logger.error("Failed to get database connection")
        return
        
    cursor = None
    try:
        is_permanent = 1 if status == 'disconnected' else 0
        cursor = db_connection.cursor(dictionary=True)
        
        # First try to update existing record
        cursor.execute(
            """
            UPDATE active_users_log 
            SET ip_address = %s,
                hostname = COALESCE(NULLIF(%s, 'Unknown'), hostname),
                last_seen = NOW(),
                connection_count = connection_count + 1,
                status = %s
            WHERE mac_address = %s
            """,
            (ip, hostname, status, mac_address.lower())
        )
        
        # If no rows were updated, insert new record
        if cursor.rowcount == 0:
            cursor.execute(
                """
                INSERT INTO active_users_log 
                (ip_address, mac_address, hostname, timestamp, 
                 status, connection_count, is_permanent,
                 data_in_mb, data_out_mb, data_usage_mb,
                 packets_in, packets_out)
                VALUES (%s, %s, %s, NOW(), %s, 1, %s, 0, 0, 0, 0, 0)
                """,
                (ip, mac_address.lower(), hostname, status, is_permanent)
            )
        
        db_connection.commit()
        logger.debug(f"Ensured device exists: MAC={mac_address}")
        
    except Exception as e:
        logger.error(f"Database save failed for MAC={mac_address}: {str(e)}")
        if db_connection:
            db_connection.rollback()
    finally:
        if cursor:
            cursor.close()
        if db_connection:
            db_connection.close()

def delete_all_from_db():
    """Clear non-permanent connected devices from the database."""
    db_connection = get_db_connection()
    if not db_connection:
        return
    try:
        cursor = db_connection.cursor()
        query = "DELETE FROM active_users_log WHERE status='connected' AND is_permanent=0"
        cursor.execute(query)
        db_connection.commit()
        deleted_count = cursor.rowcount
        logging.getLogger('NetworkEnforcer').info(f"Removed {deleted_count} non-permanent connected devices from database.")
    except mysql.connector.Error as e:
        logging.getLogger('NetworkEnforcer').error(f"Error clearing non-permanent devices: {e}")
    finally:
        cursor.close()
        db_connection.close()

def signal_all_user():
    """Clear non-permanent connected devices and signal users."""
    delete_all_from_db()
    logging.getLogger('NetworkEnforcer').info("Non-permanent connected devices cleared.")

def resolve_hostname(ip):
    """Resolve hostname for an IP."""
    try:
        return socket.gethostbyaddr(ip)[0]
    except (socket.herror, socket.gaierror):
        return "Unknown"

@lru_cache(maxsize=1)
def get_interface_details():
    """Cache network interface details."""
    try:
        gateway_info = netifaces.gateways().get("default", {}).get(netifaces.AF_INET, [None])[1]
        if not gateway_info:
            raise ValueError("No default network interface found")
        iface = gateway_info
        iface_mac = netifaces.ifaddresses(iface).get(netifaces.AF_LINK, [{}])[0].get('addr')
        if not iface_mac:
            raise ValueError(f"Could not get MAC address for interface {iface}")
        logging.getLogger('NetworkEnforcer').debug(f"Interface: {iface}, MAC: {iface_mac}")
        return iface, iface_mac
    except Exception as e:
        logging.getLogger('NetworkEnforcer').error(f"Interface detection failed: {e}")
        return "wlan0", None

def scan_network(network):
    """Scan the network for active devices with optimized parameters."""
    try:
        iface, iface_mac = get_interface_details()
        if not iface or not iface_mac:
            raise ValueError("Invalid interface or MAC address")
        arp = ARP(pdst=network)
        ether = Ether(src=iface_mac, dst="ff:ff:ff:ff:ff:ff")
        packet = ether/arp
        devices = []
        for attempt in range(2):
            try:
                responses, _ = srp(
                    packet,
                    timeout=1,
                    iface=iface,
                    verbose=False,
                    inter=0.05,
                    multi=True,
                    retry=1
                )
                devices = [(resp.psrc, resp.hwsrc.lower(), resolve_hostname(resp.psrc)) 
                         for _, resp in responses]
                break
            except Exception as e:
                if attempt == 1:
                    raise
                time.sleep(0.5)
        logging.getLogger('NetworkEnforcer').debug(f"Scanned devices: {devices}")
        return devices
    except Exception as e:
        logging.getLogger('NetworkEnforcer').error(f"Network scan failed: {e}")
        return []



def real_time_network_tracker():
    """Main loop for network monitoring."""
    enforcer = NetworkEnforcer()
    network = get_network_details()
    
    print("Starting MAC-based Network Security Monitor...")
    print("Press Ctrl+C to stop")
    
    # Initial verification
    enforcer.logger.info("Running initial verification...")
    subprocess.run(["nft", "list", "table", "inet", "traffic_accounting"], check=True)
    
    while True:
        try:
            enforcer.logger.info("--- Starting monitoring cycle ---")
            
            scanned_devices = scan_network(network) 
            current_devices = [(ip, mac) for ip, mac, _ in scanned_devices]
            enforcer.logger.info(f"Scanned devices: {current_devices}")
            
            # Verify rules exist before collection
            enforcer.logger.info("Current nftables rules:")
            subprocess.run(["nft", "list", "table", "inet", "traffic_accounting"], check=True)
            
            enforcer.traffic_monitor.update_device_rules(scanned_devices)
            enforcer.traffic_monitor.collect_traffic_stats()
            
            enforcer.logger.info(f"Traffic data before DB update: {dict(traffic_data)}")
            
            for ip, mac, hostname in scanned_devices:
                save_to_db(ip, mac, hostname, 'connected')
            
            update_database_usage()
            
            enforcer.logger.info("--- End of monitoring cycle ---")
            time.sleep(SCAN_INTERVAL)
            
        except KeyboardInterrupt:
            logging.getLogger('NetworkEnforcer').info("Network monitoring stopped by user")
            break
        except Exception as e:
            logging.getLogger('NetworkEnforcer').error(f"Tracker error: {str(e)}")
            time.sleep(5)

def get_network_details():
    """Determine the network subnet."""
    try:
        gateway_info = netifaces.gateways()["default"][netifaces.AF_INET]
        iface = gateway_info[1]
        iface_data = netifaces.ifaddresses(iface)[netifaces.AF_INET][0]
        ip_address = iface_data["addr"]
        netmask = iface_data["netmask"]
        cidr = sum(bin(int(x)).count("1") for x in netmask.split("."))
        network = f"{ip_address}/{cidr}"
        logging.getLogger('NetworkEnforcer').debug(f"Detected network: {network}")
        return network
    except Exception as e:
        logging.getLogger('NetworkEnforcer').error(f"Subnet detection failed: {e}")
        return "192.168.1.0/24"

def run():
    """Main entry point for the network scanner."""
    logging.getLogger('NetworkEnforcer').info("Starting MAC-based network monitoring system")
    try:
        real_time_network_tracker()
    except KeyboardInterrupt:
        logging.getLogger('NetworkEnforcer').info("Network monitoring stopped by user")
        sys.exit(0)
    except Exception as e:
        logging.getLogger('NetworkEnforcer').error(f"Fatal error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    logging.basicConfig(level=logging.DEBUG)
    run()